# 2-2장 데이터 액세스 기술
## 1. 데이터 엑세스 기술 공통 개념
### DAO 패턴
- DTO나 도메인 오브젝트만을 사용하는 인터페이스를 통해 데이터 엑세스 기술을 외부에 노출시키지 않는 패턴
- **DAO는 인터페이스를 이용해 접근하고 DI 되도록 만들어야 한다.**
    - DAO 인터페이스는 구체적인 데이터 액세스 기술을 포함하지 않기 때문에 데이터 액세스 기술을 분리할 수 있다.
- 데이터 액세스에서 발생하는 예외는 대부분 복구가 불가능하므로 런타임 예외로 전환해줘야 한다.
    - 가끔 예외 복구가 필요한 것들이 있긴하지만 모든 디비에 일관성이 없다면 특정 기술에 의존하게 되므로 추상화가 필요하다.
    - 추상화를 활용한 예외 전환은 AOP를 활용하면 간단히 구현할 수 있다.(이미 스프링이 기본으로 지원해준다.)

### 템플릿을 활용하여 중복 제거
- 스프링은 반복되는 트랜잭션 동기화 코드를 AOP를 활용하여 분리해 중복을 제거해준다.

### DataSource
- 스프링이 제공해주는 추상화된 인터페이스로 DB 커넥션을 가져오기 위한 커넥셜 풀을 구현하기 위한 인터페이스이다.
- DataSource는 스프링이 데이터 액세스 기술을 지원하기 위해 다양한 곳에서 사용하므로 하나의 독립된 빈으로 등록을 해주어야 한다.

### @Repository와 PersistenceExceptionTranslationPostProcessor
- @Repository는 빈으로 등록 해주는것도 있지만 데이터 액세스 기술의 추상화된 스프링 예외로 전환을 위해서 필요하기도 하다.
- PersistenceExceptionTranslationPostProcessor를 빈으로 등록하면 @Repository가 등록된 클래스를 추적하여 예외를 전환시켜준다.  

## 2. 스프링의 JDBC
- JDBC는 자바 데이터 액세스 기술의 기본이 되는 로우레벨 API로 표준 인터페이스를 제공하고 각 DB 벤더 개발팀이 해당 인터페이스를 구현한 드라이버를 제공하는 방식으로 사용된다.
- JDBC는 모든 자바 데이터 액세스 기술의 근간이므로 ORM도 내부적으로는 가장 로우레벨에서 JDBC를 사용하게 된다.
- JDBC를 직접 사용하기엔 일관성 없는 예외 처리 방식과 SQL을 텍스트로 다루어야 하는 불편함이 존재하여 스프링은 간편하게 사용이 가능한 추상화한 Spring JDBC API를 제공한다.
    - 스프링은 DB가 제공해주는 메타 정보를 활용하여 최소한의 코드로 JDBC 코드를 작성할 수 있게 해준다.

## 3. 스프링의 JPA
### EntityManagerFactory
- JPA 영속성 컨텍스트에 접근하고 엔티티를 관리하기 위한 EntityManager 생성을 담당하는 Factory 인터페이스이다.
- EntityManager는 여러 스레드에서 공통으로 사용될 수 없는 객체이므로 팩토리를 빈으로 등록하여 EntityManager를 DI받아 사용하게 된다.
    - 이거 때문에 옜날에는 @Autwried가 불가능했고 @PersistenceContext로만 DI가 가능했다. 하지만 지금은 가능해짐.
    - EntityManager는 프록시를 통해 참조되고 생명주기는 기본적으로 트랜잭션과 동일하다. 

### JPA의 LoadtimeWaver(로드타임 위버)
- JPA는 POJO 엔티티간의 관계를 활용하여 데이터 액세스 기술을 지원하기 때문에 ORM 기능(지연 로딩, 변경 감지 등)을 제공하기 위해 엔티티 클래스의 코드 조작이 필요하다.
- 보통 코드 조작은 바이트 코드 조작을 통해 구현되는데 빌드 중에 바이트 코드를 변경하는 기법이 아닌 **런타임에 클래스의 바이트 코드를 메모리에 로딩하면서 동적으로 바이트 코드를 변경하는 기법을 활용한다.**
    - 빌드 중에 바이트 코드 변경을 위해선 특정 컴파일러를 필요로 하며 빌드마다 이러한 과정이 필요하기 때문에...
- 이렇게 런타임에 바이트코드를 조작하는 것을 **로드타임 위빙**이라고 하며 이를 가능하게 하는 클래스를 **로드타임 위버**라고 한다.  

### EntityManager와 TransactionManager
- JDBC는 자체적으로 자동으로 트랜잭션 모드를 제공하여 트랜잭션 매니저가 없어도 되지만 JPA 엔티티 매니저는 반드시 트랜잭션 안에서 동작되어야 한다.
- 그러므로 JpaTransactionManager 등록이 필요하고 해당 트랜잭션 매니저에 EntityManager빈을 프로퍼티에 추가해줘야 한다.

## 4. 트랜잭션
### PlatformTransactionManager
- 스프링의 트랜잭션 서비스를 제공하기 위한 핵심 인터페이스이다.
- 해당 인터페이스의 구현체를 활용하여 트랜잭션을 관리한다.

### 여러 데이터 액세스 기술의 트랜잭션 통합
- 하나의 DB를 사용하지만 상황에 따라 JPA를, MyBatis를 사용하고 싶을 수 있다.
- 스프링은 이를 지원할 수 있도록 트랜잭션 매니저를 제공한다.

#### 1) DataSourceTransactionManager
- JDBC와 iBatis 기술을 동시에 사용할 수 있는 트랜잭션 매니저

#### 2) JpaTransactionManager
- Jpa는 기본적으로 빈으로 등록된 DataSource를 사용할 수 있으므로 JDBC, iBatis를 추가로 사용할 수 있다.
    - **이게 아까 위해서 DataSource를 빈으로 등록해줘야 하는 이유다.**

### 트랜잭션 특징
#### 트랜잭션 전파 속
- 트랜잰셕 전파란 트랜잭션의 경계에서 이미 진행중인 트랜잭션이 있거나 혹은 없을 때 어떻게 동작할지 결정하는 방식을 의미한다.

**PROPAGATION_REQUIRED**
- 가장 많이 사용하는 전파속성으로 진행 중인 트랜잭션이 있으면 해당 트랜잭션에 참여하고 없다면 트랜잭션을 새로 만든다.
- DefaultTransactionDefinition의 전파속성이 PROPAGATION_REQUIRED를 갖는다.

**PROPAGATION_REQUIRES_NEW**
- 항상 새로운 트랜잭션을 시작한다.

**PROPAGATION_NOT_SUPPORTED**
- 트랜잭션을 사용하지 않으며 진행중인 트랜잭션이 있다면 무시한다.
- 보통 트랜잭션은 AOP를 통해 설정하는데 수많은 설정 중에 특정 트랜잭션만 없애기가 쉽지않으므로 이 전파속성을 통해 트랜잭션을 무시할 수 있다.

**PROPAGATION_SUPPORTS**
- 트랜잭션이 이미 있다면 그 트랜잭션을 사용하고 없다면 트랜잭션을 사용하지 않는다.

**PROPAGATION_MANDATORY**
- 트랜잭션이 이미 있다면 그 트랜잭션을 사용하고 없다면 예외를 발생시킨다.

**PROPAGATION_NEVER**
- 트랜잭션을 사용하지 않으며 진행중인 트랜잭션이 있다면 예외를 발생시킨다.

**PROPAGATION_NESTED**
- 트랜잭션을 중첩하고 늦게 생성된 자식 트랜잭션의 롤백은 영향을 주지않지만 부모 트랜잭션의 롤백은 자식에게 영향을 준다.
- 로그같은걸 찍을 때 로그 작업이 실패하더라도 실제 로직처리를 롤백하면 안되지만 실제 로직 처리를 실패하면 로그 작업을 취소해야할 때 사용하면 좋다.

#### 격리수준
- DefaultTransactionDefinition에 설정된 격리수준은 Datasource의 기본설정에 따르는 ISOLACTION_DEFAULT이다.

#### 제한시간
- 트랜잭션을 수행하는 제한시간을 설정할 수 있다.
- DefaultTransactionDefinition의 기본설정은 제한시간이 없는 것이다.
- 트랜잭션을 직접 시작할 수 있는 PROPAGATION_REQUIRED, PROPAGATION_REQUIRES_NEW와 함께 사용해야만 의미가 있다.

#### 읽기전용
- 읽기전용으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막아줄 수 있다.
- 또한 데이터 액세스 기술에 따라서 성능이 향상될 수도 있다.

> - 트랜잭션 설정을 수정하고 싶다면 DefaultTransactionDefinition를 변경시키면된다. 하지만 이를 변경시키면 전체 트랜잭션 설정이 변경된다.
> - 원하는 메서드만 선택해서 독자적인 트랜잭션 정의를 적용할 수 없을까?
성
