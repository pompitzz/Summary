# 1-1장 오브젝트와 의존관계

## 1. 템플릿 메서드 패턴, 팩토리 메서드 패턴
- DAO를 분리할 때 부모 클래스에서 기본적인 로직의 흐름을 정의하고 일부를 서브 클래스에서 구현하게하는 `템플릿 메서드 패턴` 적용 (추상 클래스로 구현)
    - 해당 코드는 다른 메서드에서 사용할 객체를 서브클래스에서 결정하는 `팩토리 메서드 패턴`도 적용

### 장단점
- 장점
    - 이 두가지 패턴을 사용하면 관심사항이 다른 코드를 분리해내 서로 독립적으로 변경, 확장 가능하게 설계할 수 있는 간단하면서도 효과있는 방법이다
- 단점 (**상속의 단점을 정리하자**)
    - 상속을 사용하여 결합도가 증가하게 되어 유연성이 떨어지게 된다.

## 2. 상속이 아닌 결합 기법을 이용한 전략 패턴
- 자신이 의존할 객체를 선택하는 책임은 다른데서 담당하고 해당 객체는 오직 인터페이스에만 의존하도록 하여 관심사를 분리하고 확장성을 높인다.
- 의존 객체를 인터페이스에 의존하도록 하면 개방 폐쇄 원칙과 높은 응집도 및 낮은 결합도를 가질 수 있다.

### 인터페이스에 의존하여 확장성을 높일 수 있다.(개방 폐쇄 원칙)
- 인터페이스에 의존하기 때문에 의존 객체를 확장이 가능하면서 그 확장을 위해 대상 객체의 변경을 하지 않아도 된다.

### 책임을 분리하여 개발 복잡도를 줄일 수 있다.(높은 응집도와 낮은 결합도)
- 관심사가 다른 것을 의존 객체로 분리하였기 때문에 대상 객체는 하나의 책임, 관심사에 집중되어 응집도가 높아진다.
- 관심사가 분리되었기 때문에 해당 객체에서 꼭 필요한 기능을 가진 객체에게만 의존하게 되어 결합도 또한 낮아진다.(이 부분은 조금 애매한거 같다.)

## 3. 제어의 역전
### 팩토리의 목적
- 객체의 생성 방법을 결정하고 만들어주는 것을 팩토리라고 한다. 이는 디자인 패턴의 팩토리 패턴을 의미하는 것이 아니다.
- **객체를 생성하는 곳, 객체를 사용하는 곳을 분리하여 역할과 책임을 깔끔하게 분리할 수 있게 된다.**

### 프레임워크의 제어의 역전
- 애플리케이션의 전체 흐름을 개발자가 직접 제어하지 않고 프레임워크가 애플리케이션의 전체 흐름을 결정하게 되는 것.
    - 프레임워크가 애플리케이션의 전체 흐름을 주도하면서 개발자가 작성한 코드를 적절한 곳에서 사용하게 된다.
    
### 스프링 프레임워크가 IoC를 위해 주로 사용하는 기법: 의존성 주입
- 자신이 의존하는 객체들을 선택할 수 있는 제어권이 역전되어 다른 곳에서 의존 객체들을 결정해주고 해당 객체는 단지 결정된 의존 객체를 사용하기만 한다.
- 즉 의존 객체를 결정하는 곳에서 런타임에 의존 객체를 사용할 주체와 의존 객체를 연결해주게 된다.
    - 의존성 주입에는 의존 객체, 대상 객체, 의존성을 주입해줄 객체 -> 총 3가지 대상이 존재한다.

## 4. 스프링의 제어의 역전(IoC)
- 스프링은 스프링이 제어권을 가지는 빈으로 등록된 객체들을 빈 팩토리를 확장한 ApplicationContext에서 주로 관리한다.
- 이 ApplicationContext에서 빈으로 등록된 객체의 전체의 생명 주기 및 연관관계 설정등 다양한 기능을 제공하여 IoC(제어의 역전) 서비스를 제공해준다.


## 5. 싱글톤 패턴과 스프링이 제공하는 싱글톤
### 싱글톤 패턴의 한계
- 싱글톤은 보통 private 생성자와 static 필드로 구현하기 때문에 상속과 같은 객체지향 적인 특성을 누리지 못하고 테스트 작성을 어렵게 만든다.

### 스프링이 제공하는 싱글톤
- 서버 환경에서 싱글톤은 매우 유용하지만 싱글톤 패턴은 한계들이 존재한다.
- 스프링은 ApplicationContext에서 빈으로 등록된 객체들의 생명주기를 관리하기 때문에 스프링을 이용해 의존 객체들을 결정한다면 해당 객체의 싱글톤을 보장해줄 수 있다.
    - ApplicationContext에서 싱글톤을 보장해주기 때문에 해당 싱글톤 객체는 일반 자바 POJO 객체로 만들어 사용할 수 있어 객체지향 적인 특징을 누릴 수 있다.

> 스프링은 IoC 컨테이너 역할을 해주면서도 싱글톤 패턴의 한계를 극복하여 싱글톤을 보장하고 관리해주는 싱글톤 레지스트리이다.

## 6. 의존성 주입과 의존성 검색
### 스프링에서의 의존성 주입과 의존성 검색
- 의존성 검색은 주체가 되는 객체에서 의존성 검색을 위해 ApplicationContext를 의존해야 하지만 빈으로 등록되지 않아도 된다.
- 하지만 의존성 주입은 스프링 내부에서 의존성을 찾아서 주입해주기 때문에 반드시 주체가 되는 객체도 빈으로 등록되어야 한다.

### 의존성 주입의 장점
#### 1) 주체가 되는 객체 코드의 변경 없이 기능 구현의 교환과 부가기능 추가
- 인터페이스에 의존하기 때문에 해당 인터페이스를 구현한 구현체를 코드의 변경 없이 교환할 수 있다.
- 구현체를 코드의 변경 없이 교환할 수 있기 때문에 부가 기능이 추가된 구현체를 만든 후 그 구현체를 사용하도록 하여 부가기능을 추가할 수 있게 된다.

#### 2) 테스트 작성의 용이성
- 단위 테스트를 위해선 주로 의존 대상들을 목킹을 하게된다.
- 의존성 주입을 통해 의존 객체를 결정하도록 구성되어 있으면 테스트 시 의존 객체를 목킹하기 편리하다.

#### 3) 단일 책임 원칙을 지킬 수 있다.
- DI를 이용하려고 하다보면 서로 다른 책임을 가진 것들을 분리하려고 하게된다.
- 혹은 반대로 서로 다른 책임들을 분리하려고 할때 DI는 좋은 방법이다.

> DI를 이용하면 1)의 개방 폐쇄 원칙과 3)의 단일 책임 원칙을 동시에 지킬 수 있게 된다.
> - DI를 이용하면 인터페이스에 의존하기 땜누에 개방 폐쇄 원칙을 지킬 수 있게 되고, DI를 이용하면 책임들을 분리하기 쉬워지므로 단일 책임 원칙도 지킬 수 있게 해준다.

### 무조건적으로 인터페이스에 의존하도록 해야 할까?
- 책에서는 인터페이스에 의존하여야 의존성 주입이라고 할 수있다고 하지만 클래스에 의존하여 의존성 주입을 하더라도 의존성 주입의 특성을 누릴 수 있다.
    - AOP 같이 스프링 내부에서 프록시를 만들도록하여 부가 기능을 추가할 수 있을 것이다.
- 그러므로 꼭 인터페이스에만 의존하기 보다는 우선 하나의 구현만 존재한다면 클래스에 의존하도록 해도 좋은거 같다.
    - 그리고 새로운 구현이 필요해진다면 그 때 인터페이스에 의존하도록 해도 될 거 같다.
    - 혹은 부가 기능이 추가될 여지가 충분하다면 미리 인터페이스를 만드는것도 좋은거 같다.
- 그리고 기능이 변경되면 해당 구현체 자체를 변경해야 하는 경우에도 굳이 인터페이스에 의존하지 않아도 된다.

### 그럼 하나의 구현체가 있는데 왜 DI를 해야 할까?
- 해당 구현체가 추가될 수 있음을 확신할 수 없을 것이다.
- 그리고 DI를 이용하면 스프링에서 해당 객체를 관리할 수 있기 때문에 스프링의 장점을 누릴 수 있다.
