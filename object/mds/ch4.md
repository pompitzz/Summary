# Chapter 4. 설계 품질과 트레이드 오프
- 객체들이 수행할 책임이 적절하지 못하면 원할한 협력도 기대할 수 없다.
- 결국 책임이 객체지향 애플리케이션의 전체 품질을 결정한다.
- 결합도와 응집도를 합리적인 수준으로 유지하기 위해 객체의 상태가 아닌 **객체의 행동에 초점을 맞춰야 한다.**

### 상태 중심으로 설계하면?
- 객체의 상태는 객체가 직접접으로 가질 수 있는 데이터이므로 구현의 세부사항이다.
- 이러한 데이터를 먼저 결정하게 된다면 인터페이스는 해당 상태에 의해 억지로 끼워 맞출 수 밖에 없어진다.
- 이는 자연스럽지 못한 설계 방식이고, 상태가 중심이되어 다른 객체와 협력하기 위해 조건 논리를 이용하게 될 것이다.
    - 이러한 방식은 새로운 구현체들이 만들어질 때 기존 구현에게 변경을 강요하게 된다.

> 올바른 객체지향 설계의 무게중심은 항상 객체의 외부에 맞춰져 있어야 한다. 객체의 내부의 상태는 부가적인 문제일 뿐, 중요한 것은 객체들간의 협력하는 방법이다.

### 캡슐화
- 변경 가능성이 높은 것들을 객체 내부로 숨겨 추상화 시키는 기법이다.
    - 단지 객체 내부에 getter, setter를 만들어 제공한다고 캡슐화를 지킨것이 아니다.
    - 객체의 상태는 객체 스스로가 책임져야하고 필요한 경우에만 퍼블릭 메서드로 제공해줘야 한다.
- 변경 가능성이 높은 구현 부분을 상대적으로 안정적인 인터페이스와 분리하고, 구현은 캡슐화하고 인터페이스로만 객체들간의 상호작용을 하도록하면 결합도는 낮추고, 응집도를 높일 수 있다. 

### 응집도
- 모듈에 포함된 내부 요소들이 연관되어 있는 정도를 나타낸다.
- 모듈내 요소들이 하나의 목적을 위해 긴밀하게 협력하면 그 모듈은 응집도가 높다.

### 결합도
- 의존성의 정도로 어떤 모듈이 다른 모듈을 얼마나 많이 알고 있는지에 대한 정도를 나타낸다.

### 높은 응집도가 좋은 이유
- 높은 응집도를 가진다면 어떤 변경이 일어났을 때 해당 모듈 전체가 함께 변경될 것이다.
- 하지만 낮은 응집도를 가진다면 어떤 변경이 일어났을 때 여러개의 모듈이 조금씩 변경될 것이다.
- 그러므로 응집도가 높으면 변경으로 인해 수정되는 모듈이 하나로 뭉쳐지기 때문에 변경에 대한 영향을 한 모듈에만 집중할 수 있다.
 
### 낮은 결합도가 좋은 이유
- 결합도가 높으면 한 모듈이 변경될 때 함께 변경되어야 할 모듈의 수가 많아져 변경에 취약해진다.
- 결합도가 낮으면 한 모듈이 변경될 때 함께 변경되어야 할 모듈의 수가 적어져 비교적 변경에 강하다.

### 모든건 적절한 상황에서 빛을 발한다.
- 높은 응집도와 낮은 결합도는 변경이 일어날 가능성이 있는 것들에서 빛을 발한다.
- 시스템의 요구사항에 따라 만들어지는 객체들의 관계들이 그러할 것이다.
- 하지만 자바 표준 라이브러리의 String, Collection 같은 것들은 변경의 확률이 매우 낮기 때문에 낮은 결합도와 높은 응집도를 굳이 고려할 필요가 없다.


