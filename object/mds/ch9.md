# Chapter 9. 유연한 설계
## Open-Closed Principle(개방 폐쇄 원칙)
- 컴파일 타임의 의존성은 고정시키고(인터페이스에 의존하도록하여) 런타임 의존성을 변경시킬 수 있게하면 이 원칙을 지킬 수 있다.
- OCP를 지키는 코드는 컴파일 타임의 의존성을 수정하지 않고도 런타임 의존성을 변경할 수 있기 때문에 쉽게 확장이 가능하다.

> 변하는 것과 변하지 않는 것이 무엇인지를 정확히 이해하고 추상화의 목적으로 삼아야 OCP를 지킬 수 있다.

## 생성 사용 분리
- 동일한 클래스에서 객체의 생성과 사용을 담당하는건 두 가지 책임을 지게 된다.
- 유연한 설계를 위해 **생성과 사용을 분리하자**

### 순수한 가공물(Pure Fabrication)에게 책임 할당
- 모든 책임을 도메인 객체가 담당하기엔 무리가 있기 때문에 설계자의 편의를 위해 임의로 만들어낸 가공의 객체를 순수한 가공물이라고 한다.
- 이러한 순수한 가공물에게 책임을 할당하여 생성과 사용을 분리할 수 있다.

> 어떤 책임을 부여할 때 적절한 객체가 존재하지 않다면 Pure Fabrication을 추가해보자.

- 객체지향은 실세계를 기반으로 만들어졌지만 사실 인공적으로 창조한 객체들이 도메인 객체보다 더 많다.

### Pure Fabrication과 Information Expert 패턴
- Information Expert을 따르면 어떤 객체를 생성하는데 많은 정보를 가진 대상이 객체의 생성에 대한 책임을 맡도록한다.
- 하지만 이런 경우 응집도가 낮아지고, 결합도가 높아지는 경우들이 있다. 이럴땐 책임을 옮겨야 한다.
- 책임을 옮기기 가장 적절한 방법은 Pure Fabrication을 이용하는 것이다.

> Factory는 객체 생성 책임을 담당하는 순수한 가공물이라고 할 수 있다.

## 의존성 역전
- 하위 수준의 변경이 상위 수준에게 영향을 끼치면 안된다.
- 이를 지키기 위해선 추상화된 대상에게 의존하도록 하면 된다.
- 하위 수준과 상위 수준 모두 추상화된 대상에 의존하도록 하면된다.
    - A(상위 수준) -> B(하위 수준)에 의존이 필요하다면 B 클래스를 직접적으로 의존하는게 아닌 추상화된 클래스를 의존하도록 하면 된다.
    - A(상위 수준) -> C(B의 추상 클래스) <- B(C를 구현).
        - 위와 같이 상위 수준과 하위 수준 모두 추상화된 대상에 의존하도록 하여 시스템의 유연하고 재사용 가능하게 만들 수 있다. 

## 유연성은 양날의 검
- 유연성은 재사용성을 높이고 코드의 반복을 줄여 시스템을 깔끔하게 유지할 수 있다.
- 하지만 유연성이 높아질 수록 코드를 이해하기는 어려워 진다.(컴파일 타임과 런타임의 구조가 달라지기 때문에)
    - 개발자들이 복잡한 코드를 이해할 수 있을때 유연성은 가치가 있다.

