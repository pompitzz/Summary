# Chapter 12. 다형성
  
## 다형성
- 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법

### 다형성의 종류
#### 1) 유니버설 다형성
- **매개변수 다형성**
    - 제네릭에서 임의의 제네릭 타입을 지정후 실제 사용 시점에 구체적인 타입을 지정하는 방식들에 대한 것
- **포함 다형성**
    - 서브타입 다형성이라고도 하며 수신한 객체의 타입에 따라 실제 수행되는 행동이 달라지는 것
    - **객체지향에서 가장 널리 알려진 다형성으로 대부분 다형성은 이를 뜻한다.**
    
#### 2) 임시 다형성
- 오버로딩
- 강제 다형성
    - 언어가 자체적으로 지원하는 자동적인 타입 변환같은 것
     
## 상속의 양면성
- 객체는 데이터와 행동을 동시에 지니고 있기 때문에 상속에서도 데이터와 행동의 두 가지 관점을 고려해야 한다.
- **상속의 목적은 코드 재사용이 아닌 타입 계층을 구조화하기 위해 사용하여 다형성을 활용하는 것이다.**
- 타입 계층에 대한 고민 없이 코드 재사용을 위해 사용하면 유지보수가 어려운 코드가 만들어 질 수 있다.

### 1. 데이터 관점의 상속
- 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함시키는 것
- 따라서 자식 클래스의 인스턴스는 자동으로 부모 클래스에서 정의한 모든 인스턴스 변수를 포함하게 된다.

### 2. 행동 관점의 상속
- 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것(데이터는 인스턴스로 바라보지만 행동은 그렇지 않다.)
- 보통 퍼블릭 메서드는 모두 자식에게 포함되므로 자식 클래스의 메서드로 사용될 수 있다.
- **메서드가 자식에게 실제로 복사되는게 아니며, 상속 관계로 연결된 클래스간의 메서드 탐색 과정이 이루어진다.**

<br>

- 객체 인스턴스는 독립적인 메모리 공간에 존재하여야 하지만 메서드는 각 클래스에서 공유 가능하다. 
- 그러므로 각 인스턴스는 한 번만 메모리에 로딩되는 클래스에 대한 포인터를 갖고 메시지를 수신하게 되면 포인터로 가지고 있는 자신의 클래스를 기점으로 메서들르 탐색하면 될 것이다.


### 업캐스팅과 동적 메서드 바인딩
- **업캐스팅은** 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것 
- **동적 메서드 바인딩은** 컴파일 타임이 아닌 런타임에 메서드를 결정하는 매커니즘
- 이 두가지 기능이 있기 때문에 동일한 메시지에 서로 다른 메서드를 실행 하도록 할 수 있다.

### 업캐스팅은 묵시적, 다운 캐스팅은 명시적
- 부모 타입으로 선언된 변수에 자식 타입의 인스턴스를 할당하는 업캐스팅은 묵시적으로 이루어진다.
- 하지만 반대로 자식 타입으로 선언된 변수에 부모 타입 인스턴스를 할당하는 것은 명시적인 타입 변환이 필요하다.

## 동적 메서드 탐색과 다형성
### 메서드 탐색에서의 self 참조
- 객체가 메시지를 수신하면 컴파일러는 self 참조를 임시 변수로 저장 후 활용하여 메시지를 수신한 객체를 가리키도록 한다.
- 메서드 탐색이 종료되면 self 참조는 자동으로 소멸된다.

### self 참조에서 발생할 수 있는 혼란
```java
class Super {
    public void print() {
        hello();
    }

    public void hello() {
        System.out.println("super hello");
    }
}

class Sub extends Super {
    public void hello() {
        System.out.println("sub hello");
    }
}

public class ObjectBook {
    public static void main(String[] args) {
        new Sub().print(); // 뭐가 호출 될까?
    }
}
```
- 단순하게 생각하면 Super의 print()가 호출될 테니 super hello가 출력될거 같지만 그렇지 않다.
- 이 이유는 메서드가 탐색되는 과정을 이해하면 쉽게 알 수 있다.

#### 위 코드의 메서드 탐색 과정
1. self 참조를 활용하여 sub의 print 메서드 탐색 -> 메서드 없음
2. super 참조를 활용하여 부모에게 메시지를 전송하여 메서드 탐색하도록 함(직속 부모가 해당 메서드를 구현하지 않았을 수도 있으니 메서드 호출이 아닌 메서드 탐색을 위한 메시지 전송이 적절하다.)
3. 첫 번째 부모인 Super에서 print 메서드가 있으니 해당 메서드 실행
3. self 참조가 가리키는 hello 메서드 탐색 후 실행


### super는 컴파일 타임, self는 런타임
- super는 상속 관계를 이용하기 때문에 그 특징에 따라 컴파일 타임에 결정된다.
- self는 실제 self가 될지 인스턴스를 통해 결정되기 때문에 런타임에 결정된다.

### 포워딩과 위임
- 포워딩은 참조를 전달하지 않고 코드를 재사용 하는 것
- 위임은 참조를 전달하여 클래스를 이용한 상속 관계를 객체 사이의 합성 관계로 대체하여 다형성을 구현하도록 하게 한 것이다.

> 사실 자식 클래스에서 부모 클래스에게 메서드 탐색을 요청할 땐 자식 클래스의 self 참조를 넘겨서 메서드 탐색을 위임해줘야 한다.
> 하지만 대부분의 객체지향 언어 내부적으로 메시지 위임을 자동적으로 제공해준다.

### 프로토타입 기반 객체지향 언어
```js
function Lecture(name, scores) {
    this.name = name;
    this.scores = scores;
}

Lecture.prototype.stats = function () {
    return this.someMethod();
};

Lecture.prototype.someMethod = function () {
    console.log("Lecture");
};

function GradeLecture(name, scores, canceled) {
    Lecture.call(this, name, scores);
    this.canceled = canceled;
}

GradeLecture.prototype = new Lecture();
GradeLecture.prototype.constructor = GradeLecture;
GradeLecture.prototype.someMethod = function () {
    console.log("GradeLecture")
};

new GradeLecture("A", [1, 2], false).stats();
```
- 프로토 타입 기반 언어(JS)도 프로토 타입 체이닝을 활용하여 상속을 구현할 수 있다.
- 프로토타입 체이닝은 위임을 이용하여 구현되며 메서드 탐색과정이 클래스 기반 언어의 상속과 비슷하게 일어난다.
    - 단지 정적인 클래스 간의 관계까 아닌 동적인 객체 사이의 메시지 위임으로 상속이 구현된 것 뿐이다.
    
<br>

**클래스가 객체지향 패러다임에서 중요한 것이 아니다. 클래스의 상속 이외의 방법으로도 다형성을 구현할 수 있다.**
- 객체지향은 객체를 지향하는 것이며, 클래스는 단지 객체를 편리하게 관리하기 위한 하나의 수단일 뿐이다. 
